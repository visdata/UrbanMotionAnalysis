#!/usr/bin/env python
# -*- coding: utf-8 -*-
# 
# input
# [gLng, gLat, gdirStr(from or to), speed, recordNum, dLng, dLat, seg(hour ID)]

import os 
import json
# import numpy as np
import copy
from math import acos, cos, pi, floor
from util.tripFlow.base import getFormatGID
from util.tripFlow.base import parseFormatGID
from util.tripFlow.base import cosVector
from util.tripFlow.base import getRealDistance
from util.tripFlow.base import lineIntersection
from math import sqrt, pow, acos, pi, cos, sin
import simplejson


class ConstructTreeMapMM(object):
	def __init__(self, PROP):
		super(ConstructTreeMapMM, self).__init__()
		self.city = PROP['custom_params']['city']
		self.INPUT_PATH = os.path.join(PROP['IDIRECTORY'], self.city.lower()+'-byhour-res-mapped')
		self.OUTPUT_PATH = os.path.join(PROP['ODIRECTORY'], self.city.lower()+'-byhour-res-mapped')
		self.dataType = PROP['dataType']
		self.index = PROP['index']
		self.custom_params = PROP['custom_params']
		self.treeNodesID = 0
		self.locs = self.custom_params['locs']

		self.hotspotRate = PROP['hotspot_rate'] if PROP.has_key('hotspot_rate') else 0.1
		#self.GID_STD_INPUT_PATH = PROP['gid_std_directory'] if  PROP.has_key('gid_std_directory') else '/datahouse/tripflow/2019-30-800-'+self.city+'/'+self.city.lower()+'-byhour-clusterAngleRes-sorted/'
		self.GID_STD_INPUT_PATH = PROP['gid_std_directory'] if  PROP.has_key('gid_std_directory') else '/datahouse/tripflow/2019-30-800-'+self.city+'/'+self.city.lower()+'-byhour-bc-sorted/'
		self.SRC_DST_INPUT_PATH = '/datahouse/tripflow/SRCDST-BJ/bj-byhour-res/'
		self.hotspotDir = PROP['hotspot_dir'] if PROP.has_key('hotspot_dir') else 'from'
		# ȡǰ10% ���ȵ�����󷽲�����������
		self.fgidStdList = []
		self.tgidStdList = []
		self.uniformBCmetric = 5/9.0
		self.srcdstList = []
		self.dstgids = {}
		self.gridList = {
			"from":[],
			"to":[]
		}
		self.fromHubIndex = 0
		self.toHubIndex = 0
		self.tree = 0
		# todo
		# �����Ӧʱ��ε���������
		# self.fgidStdList = [[29692, 0.5084050867905752], [36245, 3.159069023678128], [28800, 3.3882662477342933], [35593, 18.839958828735472], [29094, 20.49474925410822], [40778, 21.554956779361454], [38503, 21.582659591594336], [25793, 29.849922468604944], [29093, 31.065039577828976], [30409, 34.12279920289796], [36206, 46.03156677133303], [42059, 52.13149792211946], [40156, 55.137875705030396], [35919, 57.981151297488715], [42427, 71.15839416716459], [37521, 81.81119412300275], [28790, 86.37490465457829], [38860, 88.02526827004938], [29747, 92.79803860132739], [38208, 107.58381645009023], [30407, 110.44181350658546], [27490, 141.33331299561002], [29432, 146.53296709768608], [28092, 151.48188457132537], [35914, 163.12843729141161], [30982, 188.13973708769564], [29073, 189.87058080884879], [27762, 192.85948511076575], [29421, 203.3490165341597], [45956, 211.28559399547208], [40764, 240.7415727715048], [41748, 248.9738499959582], [40129, 269.6757465327462], [17658, 277.06867138135453], [30342, 277.61889873574324], [33301, 285.92750994711224], [41456, 292.7668606209345], [34941, 302.4906204905799], [39803, 305.6059240139919], [29433, 312.6052403567723], [24183, 321.9597018109822], [28723, 337.28161235193255], [34279, 338.8909409498418], [30341, 340.17312338549925], [28416, 341.02637732500807], [37885, 349.2145935736076], [28101, 356.10207617401016], [26847, 358.4058316964057], [17659, 358.50524203721403], [28473, 362.03560794635865], [37553, 366.15690032986515], [27122, 366.3008587490043], [33968, 367.45019977134126], [33625, 375.09228713704374], [30723, 379.34421554233677], [37832, 390.8135963670216], [13789, 391.9512627661862], [31038, 402.332362074665], [27126, 403.1604420776493], [32639, 410.9400847714989], [29430, 424.06313595833745], [28437, 425.5439735549882], [27495, 427.7284663360072], [27134, 431.0536594942263], [36561, 434.850433565322], [40779, 435.79123427042293], [37532, 441.4844419878864], [30994, 448.16090078930165], [30404, 458.4385946253899], [40437, 469.0068582787521], [35578, 477.25633196677484], [43746, 477.7923499125308], [31358, 482.20831597241136], [26803, 485.25228943790455], [29419, 493.59465993721716], [28089, 493.62510581105056], [29087, 496.1224286777465], [30339, 504.01970725289374], [30359, 504.28026573635105], [22268, 511.55630378601955], [29749, 514.2433895033521], [30402, 519.9085875309455], [21590, 523.8379027045027], [29111, 533.7636045333101], [40482, 537.7921076236793], [30385, 540.8949282089086], [22267, 541.2112083546855], [38535, 545.3056202364916], [44985, 555.8229331096925], [29075, 559.0533582152169], [27164, 562.121638459718], [44984, 567.1667000333051], [40444, 575.8381350562642], [28413, 576.8910335365889], [27819, 578.0880227482644], [18663, 579.0924284623698], [40801, 581.9780142432251], [26846, 582.958053227275], [29085, 584.6440651801961], [27816, 593.7689398422082], [31017, 601.537722291474], [26843, 601.9056480408467], [37842, 602.8894656532539], [27461, 605.0272127553167], [30410, 605.7248110112074], [28751, 609.4706324619566], [37522, 613.0833576407741], [30657, 616.195410682282], [40765, 620.8741500797768], [35265, 633.1003653277246], [42387, 636.4305206681802], [29067, 637.4299709078973], [42099, 641.3082157946377], [29095, 641.7158395805267], [27443, 642.0347273506151], [28749, 647.2372580097505], [29049, 648.9340626296788], [30412, 649.1888840867576], [26801, 652.1170484260343], [34936, 671.669644639143], [30698, 674.2268487265059], [28091, 679.4281552142407], [28796, 682.5789516056124], [39792, 684.9308481603797], [24187, 688.9508158171576], [14764, 691.0432307053168], [28090, 691.3900536714436], [35590, 692.0594854900711], [27776, 694.8917972640378], [28465, 696.3449375445655], [36888, 700.4846781480649], [21295, 701.2964661369895], [32965, 705.6210175071014], [29084, 707.2441035349968], [34934, 710.7070103607464], [32041, 715.0012616992673], [40130, 720.255035770476], [27768, 722.4253061210075], [29080, 723.185401248648], [29044, 725.4953372077872], [35588, 728.9742065593178], [38810, 731.0159582620012], [42752, 735.9840533368043], [38488, 737.831045607813], [38211, 740.603235884177], [28801, 748.7810927341387], [30408, 749.5125151849497], [39143, 754.7479705416955], [38177, 755.4807918973879], [34910, 757.5691352353532], [32654, 763.0116101513227], [35261, 765.4303898347503], [22597, 771.3032903638217], [31356, 780.5125660075666], [41410, 787.0002536871805], [28789, 791.7143097214772], [39154, 791.8486907335073], [29739, 797.2240192736799], [34607, 798.9890269656191], [31659, 800.6475217534189], [19940, 802.3949314022072], [27790, 805.0691179895756], [24522, 805.5350169742776], [26800, 805.8332250493715], [19644, 806.2851957429887], [30344, 811.2968739556328], [38481, 811.8447472677823], [17009, 811.9375757567336], [32648, 813.0627648476797], [28414, 815.12988211703], [32632, 817.2225246181137], [38209, 817.2812310094785], [29742, 821.8217110480768], [27436, 822.9568094783905], [38178, 823.8512243468391], [25169, 830.3299466739635], [29409, 831.4616147305936], [28753, 836.2826658377451], [29429, 839.706067826402], [39181, 842.313236544269], [34916, 842.3306009330199], [35915, 843.9354979432949], [30346, 846.7353322811124], [32337, 857.7787854303208], [25182, 857.8777974557333], [33964, 859.4809592655258], [41735, 860.0634567712858], [27788, 863.0375955455178], [33309, 863.459095486991], [25847, 864.4498052937216], [40128, 868.0752307267082], [34940, 868.6621777379556], [30670, 878.8282539372578], [30371, 880.953061226683], [28419, 882.9571151527631], [42760, 883.3930664303053], [49849, 886.692617292342], [28111, 892.5836624807397], [28138, 894.9209029089543], [21953, 898.6683131856171], [31630, 900.8231832110348], [28099, 906.3961605482317], [20645, 908.8553647002144], [27775, 911.1866106534517], [23859, 912.8118751620401], [30981, 926.6768328576219], [36879, 928.506166660695], [33316, 930.2790969905835], [32300, 933.085551334791], [49530, 934.2014091820283], [37514, 939.411715974455], [38483, 948.5194375142311], [35904, 951.3890818273884], [42759, 956.7075445344084], [41083, 965.0017650192927], [32001, 965.8568938019316], [29043, 968.0788381591611], [28417, 969.4155305658497], [45958, 975.0734945751515], [18667, 976.9917188845878], [37226, 978.2506936112871], [28438, 978.6515283502697], [28415, 983.2043012340819], [30706, 984.305152082179], [32968, 985.1449132434051], [24509, 986.5105553003604], [39177, 989.6103626153398], [40121, 992.4158723470782], [30380, 992.8267015086084], [19994, 993.4995298593426], [29745, 994.8084941189858], [29380, 994.895793063428], [28141, 997.1163038793302], [39481, 999.5055129479965], [37512, 1007.6877440638342], [31661, 1010.4345485747257], [40768, 1010.6753455838401], [49851, 1013.0585297076314], [29048, 1016.6912655881443], [26845, 1017.6023121082887], [35912, 1018.4655777861165], [26156, 1023.785448659391], [33940, 1025.6633464901274], [23249, 1027.894283915882], [29741, 1030.06604731262], [29722, 1032.3339303116484], [29115, 1032.7109949935686], [27820, 1032.8422548503318], [20000, 1034.990639659305], [28435, 1035.5766547638052], [28142, 1037.6941981609932], [32003, 1042.2616845205152], [30364, 1046.9095826272796], [42769, 1048.3053933061426], [29718, 1051.8394363626956], [28742, 1053.173291625441], [35589, 1059.7073907164672], [33614, 1063.3302660626591], [49201, 1063.703299699262], [20328, 1066.3793704936365], [43356, 1067.4377903699597], [19963, 1074.214388575441], [20643, 1078.0529112654012], [27448, 1078.5841524379684], [27136, 1079.4496216845712], [37837, 1080.3646423797868], [36533, 1080.4619656218313], [43739, 1082.3583669644568], [49529, 1086.369597150826], [37207, 1092.3297812644457], [39478, 1093.2630203723204], [25501, 1093.5722341872347], [38532, 1094.266781073441], [28432, 1094.9973899921788], [40446, 1095.9015171195476], [43681, 1096.074906688487], [25172, 1096.7461061645065], [23861, 1099.0419571227933], [27137, 1101.2353893827385], [27757, 1103.697734329083], [38829, 1104.1931200539825], [29398, 1106.6592591454992], [26848, 1107.5683639454803], [34290, 1108.63677631871], [35881, 1108.7638051412746], [27781, 1112.576262221812], [28103, 1116.8467569565555], [38162, 1121.12185699836], [26517, 1121.123883821741], [26146, 1121.330570203104], [21627, 1122.790296332871], [38857, 1123.725282233643], [30092, 1127.5825415948436], [36896, 1130.7544703621313], [33617, 1136.0904528064161], [37513, 1138.632534143992], [29413, 1139.1440586778037], [42443, 1139.388822264046], [27449, 1140.315348418615], [27446, 1140.5841514030358], [29422, 1142.1420897678865], [30355, 1145.803983130596], [34928, 1152.5501293263058], [29068, 1159.918802970023], [43418, 1160.1830315273548], [29416, 1161.4311724378113], [33965, 1164.3254902164085], [25184, 1170.5643577360831], [28744, 1170.7190293292706], [42063, 1173.7690631378598], [19666, 1176.936212698826], [38485, 1178.5220083557865], [33944, 1179.1816849955342], [34929, 1183.329544996246], [28140, 1188.257206754723], [43738, 1189.292946186894], [35242, 1190.3527986057975], [56088, 1194.201062329102], [35247, 1198.4021239093897], [29113, 1201.6633120393728], [35263, 1203.1942326053668], [29445, 1207.2893774368006], [19642, 1208.1133166900534], [24508, 1208.9499936040684], [29705, 1216.331799985546], [30396, 1217.4974459697526], [29703, 1217.970143407025], [33615, 1218.0686786626254], [30406, 1220.0415317936584], [48874, 1224.9430452666998], [35913, 1225.2842753896705], [31340, 1228.211362983299], [32333, 1234.3577921193355], [33613, 1235.0196676642004], [24186, 1236.104434010208], [29091, 1236.9758915377697], [42442, 1237.043305205626], [37856, 1243.647829834667], [32986, 1245.7914290684541], [35264, 1245.9078206135773], [37855, 1251.925331434391], [42438, 1254.0295082103921], [26461, 1256.1505662253533], [25829, 1261.0810753240503], [48879, 1262.3198667670233], [29077, 1265.185509919356], [29117, 1265.6702307696723], [31657, 1267.9599609918673], [29408, 1268.3595564234288], [22591, 1271.3144338264242], [50176, 1271.3865827929214], [30361, 1273.8872698166672], [32335, 1280.2582743903274], [29772, 1280.7896806487129], [34590, 1286.612330908996], [30362, 1288.8281780782218], [30411, 1290.745328650006], [40440, 1291.0489178719076], [30060, 1291.0625820164664], [29089, 1296.9193583276765], [17043, 1303.3002928894718], [33945, 1303.7662442283922], [32637, 1304.6492458576859], [30345, 1305.6044406271355], [28095, 1308.9481360986615], [39153, 1309.103585943273], [21593, 1315.9437874255652], [39807, 1317.1083883861302], [27447, 1318.6264876126975], [32973, 1319.589135817857], [33949, 1323.02851235258], [34927, 1323.4640837658048], [25179, 1327.9732798949294], [18992, 1330.1606193992172], [32634, 1332.5944204246618], [28797, 1333.543065690023], [33303, 1335.7963711558925], [33299, 1337.1856546506676], [31665, 1339.2069561226865], [28433, 1339.640370734308], [39831, 1345.917174072854], [31997, 1352.6449611792632], [28146, 1353.0062071033915], [26481, 1356.4135308956925], [29410, 1360.2965224888828], [37872, 1372.434950598289], [21943, 1373.003582689447], [18017, 1373.5562714411408], [17661, 1373.9697659780138], [43743, 1375.8379230163057], [33287, 1377.1640239551077], [24834, 1388.6769532582653], [40481, 1392.4388760048832], [33622, 1392.607424854306], [35249, 1401.8333518396325], [19643, 1403.8060449548102], [29120, 1409.7436969942419], [30357, 1410.2729441272913], [38813, 1411.944800287582], [48878, 1416.0366832386962], [31354, 1416.483003967462], [26472, 1416.7908612242177], [32984, 1423.8962512156725], [40445, 1424.1731023180118], [29052, 1424.929561014517], [32647, 1426.076055493173], [29412, 1426.2389368646766], [21292, 1426.6214519770504], [28096, 1427.1540748277935], [27772, 1430.4060105337992], [18311, 1432.2657599198064], [29069, 1435.8378119857841], [37854, 1438.980560541928], [29442, 1440.599898267005], [30343, 1442.9157159396443], [31374, 1443.2309655425827], [38531, 1452.8186834887078], [43737, 1453.6148853645357], [19289, 1456.6218039450139], [27493, 1457.1860012880734], [25822, 1458.6544523838977], [35254, 1460.6446776389341], [28792, 1460.8557829083716], [31016, 1462.1221856913776], [27787, 1462.7895923490607], [26476, 1463.6589137984158], [31346, 1466.7543464839196], [49204, 1469.805662816223], [17693, 1471.952460320887], [30057, 1474.4949924231273], [29738, 1483.7032766478062], [38856, 1484.8699759556873], [31998, 1488.7605503310624], [26485, 1490.4055103361495], [38159, 1491.8204885641055], [26473, 1494.1344793346489], [34288, 1495.3413941177198], [34280, 1497.2342018415052], [39791, 1499.562471352127], [26471, 1501.0812851772478], [31034, 1501.9935453821124], [36219, 1502.4515096653556], [26799, 1513.0969849010976], [30697, 1514.6564588163071], [33612, 1515.4643990726865], [31033, 1516.23181525206], [31359, 1517.403513569614], [26466, 1518.105137621016], [29045, 1518.711570784246], [28093, 1520.23961774758], [30414, 1521.20695684326], [30381, 1521.852113898146], [29371, 1522.8058078194972], [32665, 1528.3401610217084], [30043, 1529.1065333880695], [32323, 1533.6730655052315], [40115, 1537.0912355505434], [31031, 1537.5569577691786], [29396, 1538.0068484895974], [25831, 1538.4332070302878], [34592, 1543.976232450691], [34265, 1546.9365344906066], [33289, 1549.8327383811234], [26460, 1550.9281375205642], [29734, 1552.4104060532454], [32969, 1554.5424628118328], [32334, 1559.6675060668963], [30693, 1561.8504246055427], [30668, 1562.1258877188222], [40116, 1563.1264675381728], [35253, 1565.20494518432], [28097, 1566.3115929185049], [34937, 1566.9136658711125], [27118, 1576.0102648666716], [40114, 1580.007257434666], [27763, 1580.5972456303866], [49850, 1581.9892716847867], [28104, 1587.272622436939], [49200, 1587.638662997809], [32972, 1589.1079070585586], [27780, 1590.0995777035946], [39789, 1590.1782182938084], [40447, 1590.4196004187688], [33618, 1590.9681821064364], [26149, 1597.9055062189973], [18664, 1603.4200558276164], [33306, 1604.0187144434283], [29057, 1605.6969758997093], [36860, 1605.8676949478559], [25180, 1607.1640967275828], [29771, 1613.3528952881452], [42383, 1618.1276095438736], [28763, 1621.9590413761116], [34612, 1630.326060457962], [25171, 1631.8033337558961], [34605, 1637.0003010109199], [39790, 1637.1848292015602], [18666, 1637.539679507374], [32635, 1640.1159418571804], [33627, 1646.3676044439744], [27168, 1649.8742996141664], [17366, 1653.5484515991855], [30687, 1653.811482766875], [32006, 1656.2519295653253], [34613, 1663.292489691376], [38486, 1664.348573438631], [31672, 1665.7148769540972], [27494, 1670.6196444148513], [18016, 1674.1612478424377], [29047, 1674.1762104911702], [31037, 1674.7993237222418], [34261, 1676.9130889683734], [29070, 1677.365800783689], [43031, 1678.8999570528229], [33304, 1681.5188681751379], [40453, 1682.0158844623652], [29088, 1683.3844674905658], [26796, 1684.3034298000912], [32636, 1690.5165923330278], [39479, 1691.0397187690344], [23860, 1693.631201788951], [39155, 1696.8270357977844], [27455, 1697.8411361172584], [29050, 1698.0011216131545], [27771, 1699.7724589619656], [34269, 1701.185250609589], [48877, 1701.1972960215949], [40442, 1702.0406512675515], [39468, 1702.4299304881029], [39501, 1703.2254595151824], [33291, 1705.9279254906003], [38815, 1706.7037158237492], [24209, 1709.0786824371596], [34935, 1709.7441954844596], [30682, 1713.307869035106], [19638, 1713.4757887619046], [33937, 1713.6637450165667], [33960, 1721.0464208933006], [28745, 1721.4672049309856], [28739, 1722.085581872625], [30384, 1722.2501406769668], [44064, 1723.827452691949], [33947, 1723.8566218263984], [37834, 1727.6718650098396], [31682, 1727.7527918551652], [30064, 1731.1412924293543], [32012, 1733.287128333835], [27142, 1734.7207347264764], [28431, 1734.9065996413044], [20323, 1735.9057422522376], [28436, 1736.9024995497905], [31040, 1737.4878553904773], [22264, 1738.5929188601808], [30382, 1738.6331897721213], [28429, 1738.678920488046], [29083, 1742.1569850025262], [29720, 1747.8479535954039], [29415, 1748.991588626986], [28108, 1750.6436349702287], [34591, 1751.1334416446275], [28112, 1752.9948490098654], [41123, 1753.2840843698618], [28795, 1759.5454754465534], [26474, 1763.0023031434644], [18989, 1764.0609698614674], [38182, 1766.5678132917965], [25824, 1771.699350372651], [22583, 1778.6095313190085], [29707, 1780.1221912976073], [32978, 1780.3069157687473], [29729, 1782.5201962209492], [44067, 1784.4579354899822], [34939, 1785.066962628378], [29721, 1791.799102464989], [25830, 1794.6377827874069], [29053, 1795.5300370756852], [27170, 1796.2723143068174], [35250, 1797.9519228648244], [32662, 1799.1164092147908], [20970, 1802.1869201939555], [21944, 1802.5826725371037], [29382, 1803.3477692139138], [21619, 1817.3442324252721], [34614, 1819.0760101734154], [27825, 1823.2655972428786], [19966, 1825.9954338097507], [41738, 1826.8557948683538], [28147, 1827.3133030506424], [44066, 1827.853930938598], [46282, 1833.0975757215333], [30695, 1834.6646409375705], [30058, 1838.0989919622853], [30395, 1840.3346678258627], [41774, 1841.359680438715], [25497, 1845.102485860786], [29051, 1846.311782783385], [18991, 1848.8827602828082], [29081, 1853.922799148762], [25174, 1856.4848511929551], [26157, 1857.0678203250754], [36571, 1858.6618789152622], [28087, 1858.786270514466], [34593, 1859.931485376241], [34272, 1864.1789711437946], [27821, 1867.9255662536664], [28412, 1873.3269799418692], [26783, 1877.0015495536602], [23534, 1878.4997367582841], [25825, 1878.6830970287815], [27119, 1879.2835839641002], [29695, 1887.1048312403582], [31337, 1889.041555626736], [38210, 1893.0043416457393], [17660, 1893.6957184329742], [26814, 1893.826144582604], [30369, 1896.078565717747], [21302, 1904.0559428215176], [30683, 1904.1144361233003], [40117, 1908.9907776169816], [19947, 1910.9747506168642], [37189, 1911.572534795562], [31029, 1912.471502491184], [18343, 1912.5958414245083], [28761, 1925.2492708755549], [30065, 1927.13953482466], [29082, 1932.2007382764302], [29740, 1941.7949730367416], [30415, 1951.929342963648], [27451, 1963.3362734061177], [36237, 1964.3001848404836], [32004, 1967.637860306176], [48551, 1970.9545212860414], [30365, 1972.949065334536], [29072, 1976.6211310501324], [19641, 1978.3659705883538], [17368, 1978.8112552256991], [49526, 1979.2449341553863], [28746, 1989.4492208393344], [27786, 2000.2444261543023], [26469, 2002.2711612486921], [32964, 2004.0504830821499], [29736, 2007.0245073337712], [27496, 2008.7372272376808], [29055, 2009.167840647641], [37515, 2012.325543065063], [31035, 2013.412541446948], [28144, 2014.8385535425925], [35248, 2014.955345956099], [33300, 2017.9716352900018], [31012, 2018.6649058728772], [20971, 2019.7210938511719], [34938, 2020.6692701891793], [30044, 2023.1611881174892], [34924, 2023.2139509323438], [33939, 2023.5290871845168], [30386, 2023.9659973606956], [24184, 2026.4323238986763], [28722, 2026.9259258885363], [29758, 2031.7962894611042], [33305, 2031.8902649836782], [40438, 2032.1606424095626], [42764, 2034.357204273661], [22592, 2036.1582079645257], [17691, 2043.828223780611], [23211, 2048.5920897570845], [34263, 2050.3511737325452], [28732, 2050.607306676638], [24849, 2052.731835158124], [26486, 2054.5565468915515], [29086, 2059.496104639224], [30091, 2062.418163548891], [39777, 2063.8266266314736], [30694, 2068.034150922683], [30370, 2069.131404226259], [26811, 2070.0305028538396], [24188, 2072.7145477128797], [27818, 2078.4692878433134], [28115, 2081.351558682516], [49524, 2084.6291810972984], [48876, 2085.3126750956167], [35262, 2089.094869767198], [29693, 2091.5385580524676], [31357, 2097.9802551862663], [30045, 2100.7044746363117], [28407, 2106.084247824474], [29411, 2106.268519239262], [31015, 2107.613821844412], [26797, 2107.9123940814734], [29735, 2110.199611619402], [31030, 2116.5072041014855], [34264, 2116.7141401275394], [40120, 2119.1220619692535], [37188, 2121.9382847739657], [38811, 2122.85570907629], [30383, 2126.3186210468994], [32966, 2133.3751669288554], [49203, 2138.449558599683], [33307, 2146.513538699402], [29064, 2154.358154384539], [33317, 2168.0433595778545], [32011, 2173.2351242566187], [33298, 2175.6508598291975], [30046, 2178.7066179622825], [34615, 2179.7132696855983], [32659, 2194.2617577216524], [30062, 2196.1997444469225], [32653, 2197.9544141540023], [29406, 2203.0709991396725], [29370, 2207.777084246565], [30061, 2217.184045699508], [29694, 2222.047671269933], [34604, 2222.2638157541246], [49525, 2229.393310324794], [28094, 2230.0685282125687], [33616, 2239.6525637992922], [30379, 2243.098734457492], [29407, 2243.2179125676134], [30712, 2244.1974580958595], [49199, 2246.7935415618745], [34289, 2248.3171347840803], [34274, 2252.6465078165256], [27135, 2254.686026127062], [37560, 2268.0191599068116], [26482, 2269.8935352400986], [30368, 2271.006601374933], [23535, 2271.3879423858966], [32010, 2274.8384396966985], [37838, 2277.901286194139], [17985, 2285.1243741050257], [17986, 2287.884921358757], [29060, 2291.597202388692], [29405, 2292.026268945705], [43742, 2295.662928729274], [33628, 2299.9496198819793], [35587, 2303.6815208712064], [27783, 2303.78227872816], [32013, 2306.149283296145], [33629, 2309.824707173646], [28145, 2317.9300028323514], [29737, 2321.9281858083395], [34923, 2338.1828338769005], [28726, 2341.735000417922], [23858, 2351.326165280104], [28075, 2358.8236732106525], [18310, 2360.6797348836785], [32649, 2362.5460402573526], [29404, 2367.266655627453], [38828, 2369.9713629555254], [33642, 2372.2209773737004], [43741, 2375.552223734117], [29071, 2389.4121579468147], [38812, 2395.6111131450557], [39795, 2401.465231715408], [19316, 2401.977279003011], [29058, 2407.3841914199725], [40772, 2424.0187823834926], [17367, 2432.8959022101], [30020, 2435.6639325032993], [30387, 2454.101924839197], [30707, 2458.846747832252], [26813, 2459.3849661611207], [18342, 2471.4909655668653], [33938, 2472.683404174682], [33639, 2496.6291572764835], [33302, 2498.1404976923673], [20616, 2500.9286406144984], [33619, 2505.699265793724], [34267, 2507.2784633450783], [31018, 2508.959690179471], [29114, 2516.0102958032853], [48875, 2519.1177136442716], [31670, 2523.074676516628], [33611, 2538.163699637979], [26480, 2538.7335715340864], [38158, 2541.4853661417937], [17692, 2543.4083919623645], [26805, 2553.0223406017467], [37530, 2554.229473840895], [44330, 2554.647224252092], [31036, 2555.357020700003], [29079, 2564.684127158865], [25826, 2571.7858911570797], [40441, 2579.13419515658], [37193, 2587.69258684506], [34262, 2594.8335280430656], [40443, 2628.119022281817], [32005, 2633.392044272478], [37192, 2634.3726110009047], [29728, 2644.773685054759], [34588, 2649.153681422137], [38207, 2666.6284072722706], [43416, 2687.9899360631525], [31344, 2695.2214653152323], [40454, 2695.320113647226], [33623, 2695.8300815540842], [33941, 2707.2600360947313], [28403, 2716.431779662028], [29732, 2724.951615252105], [26492, 2735.5271707404645], [32658, 2737.7557816105605], [24185, 2738.2165620155324], [31662, 2741.0511147922625], [28470, 2741.308643886322], [28765, 2753.5166391060093], [25181, 2778.345515651236], [30714, 2779.6142923948873], [29414, 2783.3803591328456], [30059, 2791.4311638600057], [31032, 2794.0458698419434], [25176, 2817.5111807475814], [32336, 2824.9438303327843], [37204, 2840.095887681552], [19618, 2872.115232547345], [31660, 2901.412352220834], [28747, 2906.464078084655], [29397, 2908.195073346333], [31019, 2927.3810085114296], [38487, 2948.06858239818], [34266, 2980.0357639263466], [32660, 2981.946203223758], [30390, 3009.8251924669785], [20291, 3015.4205877693244], [30372, 3026.2624481980633], [31688, 3056.557145040218], [36531, 3075.647994847743], [31361, 3101.798460794599], [36562, 3104.203085099962], [39826, 3115.7344403035518], [33948, 3118.0604079081622], [39506, 3124.612348542249], [29062, 3134.498446850089], [32314, 3193.5800167762263], [18341, 3233.856040932769], [21265, 3256.2524990291863], [28422, 3398.3759197825993], [28139, 3424.769949084177], [28754, 3560.2591052957923], [33640, 3565.0580236219457], [32307, 3589.634144968425], [29395, 3618.4583273242038], [35244, 3696.017569997402], [38161, 3701.9984927314954], [33315, 3769.290257482974], [30711, 3881.5784246031662], [30389, 3911.48563879576], [48225, 3926.8224740825826], [35579, 3971.7233471271356], [32319, 3972.6456635014374], [37529, 4163.23758615988], [42078, 4349.354011333023], [36863, 4523.3472698271125], [27463, 4720.680590778392]]
		# Custom Patams Foramt
		# {
		# 	'tree_num': 0,
		# 	'search_angle': 0,
		# 	'seed_strength': 0,
		# 	'max_curvation': 0,
		# 	'tree_width': 0,
		# 	'jump_length': 0,
		# 	"seed_unit": 0,
		# 	"grid_dirnum": 0,
		# }
		#self.cateKeys = {0: 'from', 1: 'to'}
		self.cateKeys = {0: 'from'}
		self.currentCateName = 'from'

		self.entries = {
			'from': [],
			'to': []
		}  # ��ʼ�㼯��
		self.currentData = {
			'from': {},
			'to': {}
		} 
		self.keepTreeStructList = {
			'from': [],
			'to': []
		}
		
		self.recDict = {
			'from': {},
			'to': {}
		}  # record �ֵ䣬key ֵΪ gid �ַ���
		self.treeMap = {
			'from': [],
			'to': []
		}  # �洢�� treemap ����

	def run(self):
		print("run")
		delta = "%.2f" % self.custom_params['delta'] 
		input_file = 'mcres-%s-%d-%s' % (self.dataType, self.index, delta)
		# input_filename = 'mcres-%d' % (self.index)
		p1 = self.custom_params['tree_num']
		p2 = self.custom_params['search_angle']
		p3 = self.custom_params['seed_strength']
		p4 = self.custom_params['tree_width']
		p5 = self.custom_params['jump_length']
		p6 = self.custom_params['seed_unit']
		p7 = self.custom_params['grid_dirnum']
		output_suffix = "%.2f_%d_%.2f_%d_%d_%s_%d" % (p1, p2, p3, p4, p5, p6, p7)
		
		output_file = 'tmres-%s-%d_%s' % (self.dataType, self.index, output_suffix)
		ifile = os.path.join(self.INPUT_PATH, input_file)
		ofile = os.path.join(self.OUTPUT_PATH, output_file)
		print(ifile)
		if not os.path.isfile(ifile):
			return False

		if self.custom_params['seed_unit'] == 'fhub' or self.custom_params['seed_unit'] == 'channel':
			self.getFGidStdListWithoutFromTo()

		if self.custom_params['seed_unit'] == 'src' or self.custom_params['seed_unit'] == 'dst' or self.custom_params['seed_unit'] == 'sd' :
			self.getPureFlowInListSorted()

		#totalNum = self.iterateFile(ifile)
		totalNum = self.iterateFileWithoutFromTo(ifile)
		roundTreeNum = int(totalNum * self.custom_params['tree_num'])
		usedNum = 0
		actualTreeNum = 0

		#print(self.cateKeys)
		#print(self.entries)

		for dirKey, cateName in self.cateKeys.iteritems():
			self.currentCateName = cateName
			for x in xrange(0, roundTreeNum):
				# ��ʼ������

				if len(self.entries[cateName]) == 0:
					break

				element = self.entries[cateName].pop()

				# onerec = "%.6f,%.6f,%s,%f,%d,%.6f,%.6f,%d,%.1f" % (gLng, gLat, 'all', speed, recordNum, lng, lat, self.index, angle)
				# linelist.extend([gid, lngind, latind, nodeID])

				self.currentData[cateName] = {
					'lng': element[0],
					'lat': element[1],
					'direction': element[5:7],
					'strength': element[4], 
					'speed': element[3],
					'count': 0
				}

				gid = str(element[-4])
				nodeId = str(element[-1])
				# ���֮ǰ�Ĳ����Ѿ�ɾ���˸ü�¼��Ӧ��
				if not self.ifNodeExist(gid, element[-1]):
					continue
				
				actualTreeNum += 1
				#self.deleteNode(gid, element[-1])
				res = {
					"root": {
						"id": self.treeNodesID,
						"lng": element[0],
						"lat": element[1],
						"dirLng": element[5],
						"dirLat": element[6],
						"num": 0,
						"speed": 0,
						"dis": 0,
						'gid': gid
					},
					"children": []
				}
				# [gLng, gLat, gdirStr(from or to), speed, recordNum, dLng, dLat, seg(hour ID)]
				#("start another seed")
				#print(element)
				#id = "%d-%s-%s" % (element[-4], element[-1], nodeId)
				childs = self.BFSOneTreeMap(element[:], element[4], [element], 0,nodeId,'forward', gid)
				res['children'] = childs

				if len(childs) > 0 and self.custom_params["seed_unit"] == 'grid':
					self.gridList[cateName].append(element)
				# todo �����to��Ҫ��ת���ӽڵ�
				if cateName == 'to' or self.custom_params['seed_unit'] == 'dst' or gid in self.dstgids.keys():
					res = self.turnOverTraj(res)
				self.treeMap[cateName].append(res)
				self.treeNodesID += 1
				currentEdgeCount = self.currentData[cateName]['count'] + 1

				# 若是hub来的方向再寻找一遍
				if self.custom_params['seed_unit'] == 'fhub':
					# element[5] = -element[5]
					# element[6] = -element[6]

					self.currentData[cateName] = {
						'lng': element[0],
						'lat': element[1],
						'direction': element[5:7],
						'strength': element[4],
						'speed': element[3],
						'count': 0
					}

					gid = str(element[-4])
					nodeId = str(element[-1])
					# ���֮ǰ�Ĳ����Ѿ�ɾ���˸ü�¼��Ӧ��
					if not self.ifNodeExist(gid, element[-1]):
						continue

					actualTreeNum += 1
					#self.deleteNode(gid, element[-1])
					res = {
						"root": {
							"id": self.treeNodesID,
							"lng": element[0],
							"lat": element[1],
							"num": 0,
							"speed": 0,
							"dis": 0,
							'gid': gid
						},
						"children": []
					}
					# [gLng, gLat, gdirStr(from or to), speed, recordNum, dLng, dLat, seg(hour ID)]
					#print("start another seed")
					#print(element)
					#id = "%d-%s-%s" % (element[-4], element[-1], nodeId)
					childs = self.BFSOneTreeMap(element[:], element[4], [element], 0,nodeId, 'reverse')
					res['children'] = childs
					if len(childs) > 0 and self.custom_params["seed_unit"] == 'grid':
						self.gridList[cateName].append(element)
					# todo �����to��Ҫ��ת���ӽڵ�
					res = self.turnOverTraj(res)
					self.treeMap[cateName].append(res)
					self.treeNodesID += 1
					currentEdgeCount = self.currentData[cateName]['count'] + 1

					print "[D-%s]#%d TMNodes Number: %d" % (cateName, x, currentEdgeCount)
					usedNum += currentEdgeCount

		print(totalNum, actualTreeNum)
		if totalNum == 0 or actualTreeNum == 0:
			print "Zero Result!"
			return 0

		print(self.tree)
		print "Edges Used Rate: %.4f" % (float(usedNum)/totalNum)
		print "Tree Average Edges Number: %.4f" % (float(usedNum)/actualTreeNum)
		self.outputToFile(ofile)



	def turnOverTraj(self, tree):
		res = []
		while tree["root"]:
			res.append(tree["root"])
			if tree.has_key("children"):
				tree = tree["children"][0]
			else:
				break

		newTree = {}
		treelen = len(res)

		for i in range(len(res)-1):
			res[i]["speed"] = res[i+1]["speed"]
    		res[len(res)-1]["speed"] = 0

		newTree["root"] = res[treelen - 1]
		newTree["children"] = [self.getChildren(res, treelen - 2)]
		return newTree


	def getChildren(self, arr, index):
		tree = {}
		tree["root"] = arr[index]
		if index - 1 >= 0:
			tree["children"] = [self.getChildren(arr, index - 1)]
   	 	return tree


	def getFGidStdList(self):
		"""
		��ȡfrom gid list �켣��������hotspot Ĭ��ȡǰ10%, Ȼ���շ����С����
		:return:
		"""

		if int(self.index) >= 4000:
			ifilename = '%d-%d-%s.json' % (int(self.index), self.index, 'from')
			ifilename_to = '%d-%d-%s.json' % (int(self.index), self.index, 'to')
		else:
			ifilename = '%d-%d-%s.json' % (int(self.index % 24), self.index, 'from')
			ifilename_to = '%d-%d-%s.json' % (int(self.index % 24), self.index, 'to')

		with open(self.GID_STD_INPUT_PATH + ifilename, 'r') as f:
			gidStdList = simplejson.load(f)
			hotspotIndex = int(floor(len(gidStdList) * (1 - self.hotspotRate)))

			for i in range(hotspotIndex, len(gidStdList)):
				self.fgidStdList.append([int(gidStdList[i][0]), gidStdList[i][1]])

			self.fgidStdList.sort(key=lambda x:x[1])
		f.close()


		with open(self.GID_STD_INPUT_PATH + ifilename_to, 'r') as f:
			gidStdList = simplejson.load(f)
			hotspotIndex = int(floor(len(gidStdList) * (1 - self.hotspotRate)))

			for i in range(hotspotIndex, len(gidStdList)):
				self.tgidStdList.append([int(gidStdList[i][0]), gidStdList[i][1]])

			self.tgidStdList.sort(key=lambda x:x[1])
		f.close()

	def getPureFlowInListSorted(self):
		if int(self.index) >= 4000:
			ifilename = '%d-%d' % (int(self.index), self.index)
		else:
			ifilename = '%d-%d' % (int(self.index % 24), self.index)
		with open(self.SRC_DST_INPUT_PATH + ifilename, 'rb') as f:
			for record in f:
				record = record.strip('\n')
				columns = record.split(',')
				pureflow = int(columns[2])-int(columns[1])
				if columns[0] == '29076':
					pureflow = 0
				self.srcdstList.append([int(columns[0]),pureflow])
		self.srcdstList.sort(key=lambda x:x[1])

	def getFGidStdListWithoutFromTo(self):
		"""
		��ȡfrom gid list �켣��������hotspot Ĭ��ȡǰ10%, Ȼ���շ����С����
		:return:
		"""

		if int(self.index) >= 4000:
			ifilename = '%d-%d-%s.json' % (int(self.index), self.index, 'all')
			#ifilename_to = '%d-%d-%s.json' % (int(self.index), self.index, 'to')
		else:
			ifilename = '%d-%d-%s.json' % (int(self.index % 24), self.index, 'all')
			#ifilename_to = '%d-%d-%s.json' % (int(self.index % 24), self.index, 'to')

		with open(self.GID_STD_INPUT_PATH + ifilename, 'r') as f:
			gidStdList = simplejson.load(f)
			hotspotIndex = int(floor(len(gidStdList) * (1 - self.hotspotRate)))

			for i in range(hotspotIndex, len(gidStdList)):
				self.fgidStdList.append([int(gidStdList[i][0]), gidStdList[i][1]])

			#self.fgidStdList.sort(key=lambda x:x[1])
			#bc reverse
			self.fgidStdList.sort(key=lambda x:x[1],reverse=True)
		f.close()


		# with open(self.GID_STD_INPUT_PATH + ifilename_to, 'r') as f:
		# 	gidStdList = simplejson.load(f)
		# 	hotspotIndex = int(floor(len(gidStdList) * (1 - self.hotspotRate)))
        #
		# 	for i in range(hotspotIndex, len(gidStdList)):
		# 		self.tgidStdList.append([int(gidStdList[i][0]), gidStdList[i][1]])
        #
		# 	self.tgidStdList.sort(key=lambda x:x[1])
		# f.close()


	def iterateFileWithoutFromTo(self, ifile):
		"""
		遍历文件，构建 gid-record 字典以及种子方向列表
			:param self:
			:param ifile:
		"""
		#cateKeys = self.cateKeys
		cateKeys = {0: 'from'}
		seedUnit = self.custom_params['seed_unit']
		gridDirNum = self.custom_params['grid_dirnum']

		# 网格列表以及网格与所属记录的对应字典
		gridDevNumDict, gridDevNumList = { 'from': {}, 'to': {} }, { 'from': [], 'to': [] }
		gridRecsDict = { 'from': {}, 'to': {} }

		with open(ifile, 'rb') as f:
			nodeID = 0
			for line in f:
				line = line.strip('\n')
				linelist = line.split(',')

				# onerec = "%.6f,%.6f,%s,%f,%d,%.6f,%.6f,%d,%.1f" % (gLng, gLat, 'all', speed, recordNum, lng, lat, self.index, angle)

				linelist[0] = float(linelist[0])
				linelist[1] = float(linelist[1])

				linelist[8] = float(linelist[8])

				formatGID = getFormatGID([linelist[0], linelist[1]], self.custom_params['LngSPLIT'], self.custom_params['LatSPLIT'], self.locs)
				# {gid, lngind, latind} = formatGID
				gid = formatGID['gid']
				lngind = formatGID['lngind']
				latind = formatGID['latind']
				#gdirStr = linelist[2]
				gdirStr = 'from'

				linelist[6] = float(linelist[6])
				linelist[5] = float(linelist[5])

				linelist[3] = float(linelist[3])
				linelist[4] = int(linelist[4])

				linelist.extend([gid, lngind, latind, nodeID])
				nodeID += 1

				strGID = str(gid)
				if strGID in gridDevNumDict[gdirStr].keys():
					gridDevNumDict[gdirStr][strGID] += linelist[4]
					gridRecsDict[gdirStr][strGID].append(linelist[:])
				else:
					gridDevNumDict[gdirStr][strGID] = linelist[4]
					gridRecsDict[gdirStr][strGID] = [linelist[:]]

				# res[gdirStr].append(linelist[:])
		f.close()

		# 构建 grid 排序数组
		for dirKey, cateName in cateKeys.iteritems():
			for key, val in gridDevNumDict[cateName].iteritems():
				gridDevNumList[cateName].append([key, val])

		# 前 N 方向筛选
		N = self.custom_params['grid_dirnum']
		if N == -1:
			N = 999

		res = {
			'from': [],
			'to': []
		}

		for dirKey, cateName in cateKeys.iteritems():
			for gid, reclist in gridRecsDict[cateName].iteritems():
				reclist.sort(key=lambda x:x[4], reverse=True)
				if len(reclist) >= N:
					res[cateName] += reclist[0:N]
				else:
					res[cateName] += reclist[:]

		# 分 from/to 方向，按照 deviceNum 排序
		for dirKey, cateName in cateKeys.iteritems():
			nodeLen = len(res[cateName])
			for i in xrange(0, nodeLen):
				currentLine = res[cateName][i]
				gidStr = str(currentLine[-4])
				if gidStr in self.recDict[cateName].keys():
					self.recDict[cateName][gidStr].append(currentLine)
				else:
					self.recDict[cateName][gidStr] = [currentLine]


		resInAll = copy.deepcopy(res)
		resByGID = copy.deepcopy(gridRecsDict)
		self.pickUpSeedsWithoutFromTo(resInAll, gridDevNumList, resByGID)

		#print nodeID
		return int(nodeID/2)


	def pickUpSeedsWithoutFromTo(self, resInAll, gridDevNumList, resByGID):
		#cateKeys = self.cateKeys
		cateKeys = {0: 'from'}

		# basic 方式筛选种子
		for dirKey, cateName in cateKeys.iteritems():
			if self.custom_params['seed_unit'] == 'basic':
				resInAll[cateName].sort(key=lambda x:x[4], reverse=True)

				nodeLen = len(resInAll[cateName])
				treeNum = floor(self.custom_params['tree_num'] * nodeLen)
				for i in xrange(0, nodeLen):
					currentLine = resInAll[cateName][i]

					if i < treeNum:
						self.entries[cateName].append(currentLine[:])
			elif self.custom_params['seed_unit'] == 'grid':
				gridDevNumList[cateName].sort(key=lambda x:x[1], reverse=True)

				gridLen = len(gridDevNumList[cateName])
				treeNum = int(floor(self.custom_params['tree_num'] * gridLen))

				for i in xrange(0, treeNum):
					gid = gridDevNumList[cateName][i][0]
					self.entries[cateName] += resByGID[cateName][gid][:]

			elif self.custom_params['seed_unit'] == 'dst' or self.custom_params['seed_unit'] == 'sd':

				cateName = 'from'
				srcCount = self.srcdstList[len(self.srcdstList) - 1][1]*(1-self.custom_params['tree_num'])
				#srcIndex = int(floor(len(self.srcdstList) * self.custom_params['tree_num']))
				for i in xrange(len(self.srcdstList)-1, -1 ,-1):
					gid = str(self.srcdstList[i][0])
					if self.srcdstList[i][1] >= srcCount and resByGID[cateName].has_key(gid):
						self.dstgids[gid] = True
						self.entries[cateName] += resByGID[cateName][gid][:]
					elif self.srcdstList[i][1] < srcCount:
						break
			if self.custom_params['seed_unit'] == 'src' or self.custom_params['seed_unit'] == 'sd':
				#TODO
				cateName = 'from'
				srcCount = self.srcdstList[0][1]*(1-self.custom_params['tree_num'])
				#srcIndex = int(floor(len(self.srcdstList) * self.custom_params['tree_num']))
				for i in xrange(0, len(self.srcdstList)):
					gid = str(self.srcdstList[i][0])
					if self.srcdstList[i][1] <= srcCount and resByGID[cateName].has_key(gid):
						self.entries[cateName] += resByGID[cateName][gid][:]
					elif self.srcdstList[i][1] > srcCount:
						break



			elif self.custom_params['seed_unit'] == 'fhub' or self.custom_params['seed_unit'] == 'thub':
				# todo
				tmpList = copy.deepcopy(self.fgidStdList)
				def myCmp(x,y):
					if abs(y[1]-self.uniformBCmetric) >  abs(x[1]-self.uniformBCmetric):
						return 1
					else:
						return 0

				tmpList.sort(cmp=myCmp)

				if cateName == 'from':
					hubIndex = int(floor(len(self.fgidStdList) * (1 - self.custom_params['tree_num'])))
					self.fromHubIndex = hubIndex
					for i in xrange(hubIndex, len(tmpList)):
						gid = str(tmpList[i][0])
						self.entries[cateName] += resByGID[cateName][gid][:]

				elif cateName == 'to':
					hubIndex = int(floor(len(self.tgidStdList) * (1 - self.custom_params['tree_num'])))
					self.toHubIndex = hubIndex
					for i in xrange(hubIndex, len(self.tgidStdList)):
						gid = str(self.tgidStdList[i][0])
						self.entries[cateName] += resByGID[cateName][gid][:]


			elif self.custom_params['seed_unit'] == 'channel':
				# todo


				if cateName == 'from':
					channelIndex = int(floor(len(self.fgidStdList) *  self.custom_params['tree_num']))
					for i in xrange(0, channelIndex):
						gid = str(self.fgidStdList[i][0])
						self.entries[cateName] += resByGID[cateName][gid][:]
				elif cateName == 'to':
					channelIndex = int(floor(len(self.tgidStdList) *  self.custom_params['tree_num']))
					for i in xrange(0, channelIndex):
						gid = str(self.tgidStdList[i][0])
						self.entries[cateName] += resByGID[cateName][gid][:]

	def BFSOneTreeMap(self, parentNode, recordNum=0, treeQueue=[], currentDis=0, nodeId=0, searchDirection='forward', gid=0):
		
		# childs = self.BFSOneTreeMap(element[:], element[4], [element], 0,nodeId,'forward', gid)
		cateName = self.currentCateName

		self.treeNodesID += 1
		
		for each in treeQueue:
			id = "%d-%s-%s" % (each[-4], each[-1], nodeId)
			if id not in self.keepTreeStructList[cateName]:
				self.keepTreeStructList[cateName].append(id)

		#print(self.keepTreeStructList['from'])

		#print(self.keepTreeStructList['from'])



		# keepTreeStructList = {
		# 	'from': [],
		# 	'to':[]
		# }
        #
		# for each in treeQueue:
		# 	id = "%d-%s" % (each[-4], each[-1])
		# 	if id not in keepTreeStructList[cateName]:
		# 		keepTreeStructList[cateName].append(id)

		queue = []
		# parentNRN = parentNode[4]
		# nothing = True

		#[gLng, gLat, gdirStr(from or to), speed, recordNum, dLng, dLat, seg(hour ID)]

		if searchDirection == 'reverse':
			parentNode[5] = 0-parentNode[5]
			parentNode[6] = 0-parentNode[6]
		# ����������㣬�ó����� gid��Ȼ��ƥ�䷽����� queue
		point = [parentNode[0], parentNode[1], parentNode[-4]]

		# todo: ��Ҫ�ж���to����from,ֻ�и��ڵ���ж�from/to
		direction = [parentNode[5], parentNode[6]]
		#if currentDis == 0 and parentNode[2] =='to':
			#direction = [-parentNode[5], -parentNode[6]]


		tmpStepRes = self.getNextGIDs(point, direction)
		gids = tmpStepRes['res']
		intersectionPoint = tmpStepRes['endPoints']
		# originGid = tmpStepRes['originGid']

		# maintain an gid info map: gid -> index of gids

		gidsIndexMap = {}

		for index in range(len(gids)):
			gidsIndexMap[str(gids[index][2])] = index

		queue += self.getNextDirections(gids, parentNode, searchDirection)

		res = []

		#print("que len is " + str(len(queue)))
		#print(queue)
		# BFS Looping Condition
		#print("current node id is:" + nodeId)
		while queue:

			vertex = queue.pop(0)
			treeQueue.append(vertex)
			gidStr = str(vertex[-4])
			nodeID = vertex[-1]

			treeStructID = "%s-%s-%s" % (gidStr, nodeID, nodeId)
			if treeStructID in self.keepTreeStructList[cateName]:
				#print treeStructID + "node has been used"
				continue

			# if treeStructID in keepTreeStructList[cateName]:
			#  	continue
			
			# �����ж� START
			dis = currentDis + getRealDistance(parentNode[0], parentNode[1], vertex[0], vertex[1])
			if dis > self.custom_params['max_distance'] * 1000:
				continue
			# �����ж� END

			self.treeNodesID += 1
			self.currentData[cateName]['count'] += 1 

			subres = {
				"root": {
					"id": self.treeNodesID,
					"lng": vertex[0],
					"lat": vertex[1],
					"dirLng": vertex[5],
					"dirLat": vertex[6],
					"num": parentNode[4],
					"speed": parentNode[3],
					"dis": dis
				},
				"children": [  ]
			}

			#node = self.deleteNode(gidStr, nodeID)
			childs = self.BFSOneTreeMap(vertex, vertex[4], treeQueue, dis,nodeId, searchDirection,gid)
			#print('childs len is:' + str(len(childs)))
			if len(childs)>1 :
				self.tree += 1
			# nothing = False
			subres['children'] = childs
			#print('push one child')
			res.append(subres)

		if len(res) == 0:
			self.treeNodesID += 1
			self.currentData[cateName]['count'] += 1 
			res.append({
				"root": {
					"id": self.treeNodesID,
					"lng": intersectionPoint[0],
					"lat": intersectionPoint[1],
					"dirLng": parentNode[5],
					"dirLat": parentNode[6],
					"num": parentNode[4],
					"speed": parentNode[3],
					"dis": currentDis + getRealDistance(parentNode[0], parentNode[1], intersectionPoint[0], intersectionPoint[1])
				}
			})
		# result
		# if nothing:
		# 	del res['children']
		
		#print('Children len is '+str(len(res)))
		return res

	def getNextGIDs(self, point, direction):
		"""
		��ȡ���������ǰ N ������
			:param self: 
			:param point: [lng, lat, gid] 
			:param direction: 
		"""
		res = []
		[x, y] = direction
		fromLat = point[1]
		fromLng = point[0]
		fromGID = point[2]
		parsedObj = parseFormatGID(fromGID, 'n', self.custom_params['LngSPLIT'], self.custom_params['LatSPLIT'], self.locs)
		baseLatCenter = parsedObj['lat']
		baseLngCenter = parsedObj['lng']

		latDir = 1.001 if y > 0 else -1.001
		lngDir = 1.001 if x > 0 else -1.001

		# �洢���н�������
		jumpPoints = []

		# �������񷽱߽���
		if y != 0:  # ��ƽ��γ�����ཻ
			k = x / y
			for i in xrange(0, self.custom_params['jump_length']):
				incrementLat = baseLatCenter + self.custom_params['LatSPLIT'] * (0.5 + i) * latDir - fromLat
				iLng = fromLng + incrementLat * k
				iLat = fromLat + incrementLat
				# key = '0,%d' % (i)
				jumpPoints.append([iLng, iLat, 0, i])

		if x != 0:  # ��ƽ�о������ཻ
			k = y / x
			for i in xrange(0, self.custom_params['jump_length']):
				incrementLng = baseLngCenter + self.custom_params['LngSPLIT'] * (0.5 + i) * lngDir - fromLng
				iLat = fromLat + incrementLng * k
				iLng = incrementLng + fromLng
				# key = '%d,0' % (i)
				jumpPoints.append([iLng, iLat, i, 0])

		if x != 0 and y != 0:
    		# ����γ�ȴ�С������ǰ��
			for i in xrange(self.custom_params['jump_length'], self.custom_params['jump_length'] * 2):
				currentIndex = -1
				currentMax = jumpPoints[i][0]
				
				for jumpIndex in xrange(0, self.custom_params['jump_length']):
					if (jumpPoints[jumpIndex][0] * lngDir) > (currentMax * lngDir):
						currentIndex = jumpIndex
						currentMax = jumpPoints[jumpIndex][0]

				if currentIndex != -1:
					jumpPoints[currentIndex] = jumpPoints[i][:]
		
		# ȷ���÷�����Բ����С�Ľ���
		minLng = jumpPoints[0][0]
		minLat = jumpPoints[0][1]
		originGid = 0
		if x != 0 and y != 0:
			for i in xrange(1, self.custom_params['jump_length']):
				if minLng * lngDir > jumpPoints[i][0] * lngDir:
					minLng = jumpPoints[i][0]
					minLat = jumpPoints[i][1]

		# ֻȡ��������
		updateOriginGid = False
		for i in xrange(0, self.custom_params['jump_length']):
			ilng = jumpPoints[i][0]
			ilat = jumpPoints[i][1]

			# if ilng == minLng and ilat == minLat:
			# 	updateOriginGid = True

			if jumpPoints[i][2] == 0:
				ilat += 0.002 * latDir  # 0.002 ΪһС��ƫ����ʹ�����ڶ�Ӧ�����ڶ�������ֻ���ڱ߽���
			else:
				ilng += 0.002 * lngDir

			point = getFormatGID([ilng, ilat], self.custom_params['LngSPLIT'], self.custom_params['LatSPLIT'], self.locs)
			gid = point['gid']
			# if updateOriginGid:
			# 	updateOriginGid = False
			# 	originGid = gid
			res.append([ilng, ilat, gid])
		
		return {
			'res': res,
			'endPoints': [minLng, minLat]
			# 'originGid': originGid
		}
	
	def getNextDirections(self, gids, parentNode,searchDirection):
		"""
		��ȡ��������ӽ������� N �����򲢷��أ� gids �е� lng/lat ��ͬ
			:param self: 
			:param gids: 
			:param parentNode: 
		"""
		topSearchs = []
		topSearchAngles = []
		res = []
		gidsLen = len(gids)

		# ÿ���������
		for index in xrange(0, gidsLen):
			gid = str(gids[index][2])
			if gid not in self.recDict["from"].keys():
				continue
			recsLen = len(self.recDict["from"][gid])


			# ÿ�������еķ������
			for subIndex in xrange(0, recsLen):
				# ���¾�γ�ȵ����㣬����ԭ�������е�
				# self.recDict[cateName][gid][subIndex][0] = gids[index][0]
				# self.recDict[cateName][gid][subIndex][1] = gids[index][1]

				#if cateName == "to":
					#self.recDict[cateName][gid][subIndex][5] = - self.recDict[cateName][gid][subIndex][5]
					#self.recDict[cateName][gid][subIndex][6] = - self.recDict[cateName][gid][subIndex][6]
				rec = copy.deepcopy(self.recDict["from"][gid][subIndex])
				validation = self.judgeRecordLegality(rec, parentNode, searchDirection)
				if validation["res"]:
    				# ������������ķ��򣬽��зֲ���
					if len(topSearchs) < self.custom_params['tree_width']:
						topSearchs.append(rec[:])
						topSearchAngles.append(validation['mixAngle'])
					else:
						maxAngleIndex = -1
						maxAngle = validation['mixAngle']
						for topIndex in xrange(0, self.custom_params['tree_width']):
							tmpAngle = topSearchAngles[topIndex]
							if maxAngle < tmpAngle:
								maxAngleIndex = topIndex
								maxAngle = tmpAngle
						
						# �滻����ǰ���ƫ��ķ���
						if maxAngleIndex != -1:
							topSearchs[maxAngleIndex] = rec[:]
							topSearchAngles[maxAngleIndex] = validation['mixAngle']
		
		#print "TopSearch len is :" +str(len(topSearchs))
		#print(topSearchs)
		return topSearchs

	def judgeRecordLegality(self, rec, parentNode, searchDirection):
		cateName = self.currentCateName

		currentPoint = rec[0:2]
		currentDirection = rec[5:7]
		currentStrength = rec[4]
		currentGrid = int(rec[-4])
		currentLine = [currentPoint, [currentPoint[0] + currentDirection[0], currentPoint[1] + currentDirection[1]]]

		parentPoint = [parentNode[0], parentNode[1]]
		parentDirection = [parentNode[5], parentNode[6]]

		if searchDirection=='reverse':
			parentDirection = [-parentNode[5], -parentNode[6]]
		# parentStrength = parentNode[4]

		parentLine = [parentPoint, [parentPoint[0] + parentDirection[0], parentPoint[1] + parentDirection[1]]]

		intersectionPoint = lineIntersection(currentLine, parentLine)

		if !intersectionPoint:
			return {
				"res": False,
				"reason": "do not intersect"
			}

		intersectionGID = getFormatGID(intersectionPoint, self.custom_params['LngSPLIT'], self.custom_params['LatSPLIT'], self.locs)['gid']

		if intersectionGID != currentGrid:
			return {
				"res": False,
				"reason": "intersection not in the next grid"
			}
		else:
			rec[0] = intersectionPoint[0]
			rec[1] = intersectionPoint[1]

		currentAngle = acos(cosVector(parentDirection, currentDirection)) * 180 / pi
		if currentAngle < -self.custom_params['search_angle'] or currentAngle > self.custom_params['search_angle']:
			return {
				"res": False,
				"reason": "bigger than search angle"
			}
			#return False

		
		initDirection = self.currentData[cateName]['direction']
		accumulatedAngle = acos(cosVector(initDirection, currentDirection)) * 180 / pi
		if accumulatedAngle < -self.custom_params['max_curvation'] or accumulatedAngle > self.custom_params['max_curvation']:
			return {
				"res": False,
				"reason": "more than max curvation"
			}
			#return False

		if currentStrength < self.currentData[cateName]['strength'] * self.custom_params['seed_strength']:
			return {
				"res": False,
				"reason": "record strength too small"
			}
			#return False
		
		mixAngle = cos(currentAngle) * currentStrength

		return {
			'res':True,
			'mixAngle': mixAngle,
			'currentAngle': currentAngle,
			'accumulatedAngle': accumulatedAngle
		}

	def deleteNode(self, gid, nodeID):
		"""
		���� gid �Լ� node ���ɾ����Ӧ��¼
			:param self: 
			:param gid: 
			:param nodeID: 
		"""
		cateName = self.currentCateName
		if cateName == "to":
			return
		gid = str(gid)
		# print "Delete GID %s nodeID %s" % (gid, nodeID)

		nodesLen = len(self.recDict[cateName][gid])

		for x in xrange(0, nodesLen):
			if self.recDict[cateName][gid][x][-1] == nodeID:
				if len(self.recDict[cateName][gid]) == 1:
					# res = self.recDict[gid][0][:]
					self.recDict[cateName].pop(gid, None)
				else: 
					# res = self.recDict[gid][x][:]
					del self.recDict[cateName][gid][x]
				return True
	
	def ifNodeExist(self, gid, nodeID):
		"""
		���� gid �Լ� node ���ɾ����Ӧ��¼
			:param self: 
			:param gid: 
			:param nodeID: 
		"""
		cateName = self.currentCateName
		gid = str(gid)
		if gid not in self.recDict[cateName].keys():
			return False

		nodesLen = len(self.recDict[cateName][gid])

		for x in xrange(0, nodesLen):
			if self.recDict[cateName][gid][x][-1] == nodeID:
				return True
		
		return False

	def appendNode(self, data, gid):
		cateName = self.currentCateName

		if gid in self.recDict[cateName].keys():
			self.recDict[cateName][gid].append(data)
		else:
			self.recDict[cateName][gid] = [data]

	def outputToFile(self, ofile):
		print(ofile)
		with open(ofile, 'wb') as f:
			json.dump({
				'res': self.treeMap,
				'len': len(self.treeMap['from']) + len(self.treeMap['to']),
				'fromGidList': self.fgidStdList[self.fromHubIndex - 1:],
				#'toGidList': self.tgidStdList[self.toHubIndex - 1:],
				'gridList': self.gridList
			}, f)
		f.close()